#ifndef OPENCLX_BITS_MACROS
#define OPENCLX_BITS_MACROS

#define CLX_GET_STRING(function, key) \
	size_t actual_size = 0; \
	std::string value(4096, ' '); \
	errc ret; \
	bool success = false; \
	while (!success) { \
		ret = errc( \
			function(this->_ptr, key, value.size(), &value[0], &actual_size) \
		); \
		value.resize(actual_size); \
		if (ret != errc::invalid_value && actual_size <= value.size()) { \
			CLX_CHECK(ret); \
			success = true; \
		} \
	} \
	while (!value.empty() && value.back() == 0) { value.pop_back(); } \
	return value;

#define CLX_GET_STRING3(method, function, key) \
	std::string \
	method() const { \
		CLX_GET_STRING(function, key); \
	}

#define CLX_GET_ARRAY(function, key, type, return_type) \
	size_t actual_size = 0; \
	static_assert(sizeof(type) == sizeof(return_type), "bad size"); \
	std::vector<return_type> result(4096 / sizeof(return_type)); \
	int_type ret; \
	bool success = false; \
	while (!success) { \
		ret = function( \
			this->_ptr, \
			key, \
			result.size()*sizeof(return_type), \
			result.data(), \
			&actual_size \
		); \
		result.resize(actual_size); \
		if (errc(ret) != errc::invalid_value && actual_size <= result.size()) { \
			CLX_CHECK(ret); \
			success = true; \
		} \
	} \
	return result;

#define CLX_GET_SCALAR3(function, key, type) \
	type value = 0; \
	CLX_CHECK(function(this->_ptr, key, sizeof(type), &value, nullptr)); \
	return value;

#define CLX_GET_SCALAR4(function, key, type, return_type) \
	type value = 0; \
	CLX_CHECK(function(this->_ptr, key, sizeof(type), &value, nullptr)); \
	return static_cast<return_type>(value);

#define CLX_GET_SCALAR5(name, function, key, type, return_type) \
	auto \
	name() const -> return_type { \
		CLX_GET_SCALAR4(function, key, type, return_type) \
	}

#define CLX_GET_STRUCT4(name, function, key, type) \
	auto \
	name() const -> type { \
		type value{}; \
		CLX_CHECK(function(this->_ptr, key, sizeof(type), &value, nullptr)); \
		return value; \
	}

#endif // vim:filetype=cpp
