#ifndef OPENCLX_CONTEXT_PROPERTIES
#define OPENCLX_CONTEXT_PROPERTIES

#include <openclx/forward>

namespace clx {

	class context_properties {

	public:
		typedef void (*printf_callback_type)(
			const char* buffer,
			size_t len,
			size_t complete,
			void* user_data
		);

	private:
		bool_type _terminated{CL_FALSE};
		printf_callback_type _printf_callback = nullptr;
		size_t _printf_buffer_size = 0;
		unsigned_int_type _initmemory = 0;

	public:
		inline bool_type can_be_terminated() const { return this->_terminated; }
		inline void can_be_terminated(bool b) {
			this->_terminated = static_cast<bool_type>(b); }

		inline void
		printf_callback(printf_callback_type cb) {
			this->_printf_callback = cb;
		}

		inline printf_callback_type
		printf_callback() const {
			return this->_printf_callback;
		}

		inline void printf_buffer_size(size_t n) { this->_printf_buffer_size = n; }
		inline size_t printf_buffer_size() const { return this->_printf_buffer_size; }

		inline void init_memory(unsigned_int_type rhs) { this->_initmemory = rhs; }
		inline unsigned_int_type init_memory() const { return this->_initmemory; }

		std::vector<context_properties_type>
		operator()(const platform& platform) const;

	};

	template <class T>
	inline std::vector<context_properties_type>&
	operator<<(std::vector<context_properties_type>& out, const T& rhs) {
		out.emplace_back(context_properties_type(rhs));
		return out;
	}



}

#endif // vim:filetype=cpp
