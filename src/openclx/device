#ifndef OPENCLX_DEVICE
#define OPENCLX_DEVICE

#include <chrono>
#include <string>
#include <vector>

#include <openclx/command_queue>
#include <openclx/command_queue_flags>
#include <openclx/context>
#include <openclx/device_affinity_domain>
#include <openclx/device_flags>
#include <openclx/device_local_memory>
#include <openclx/device_memory_cache>
#include <openclx/device_partition>
#include <openclx/error>
#include <openclx/execution_flags>
#include <openclx/floating_point_flags>
#include <openclx/forward>

namespace clx {

	class device {

	public:
		typedef std::chrono::nanoseconds nanoseconds;

	protected:
		device_type _ptr = nullptr;

	public:

		inline explicit
		device(device_type ptr): _ptr(ptr) {}

		#if CL_TARGET_VERSION >= 120
		device parent() const;

		unsigned_int_type max_subordinate_devices() const;
		device_affinity_domain affinity_domain() const;

		std::vector<device>
		partition(unsigned int num_compute_units) const;

		std::vector<device>
		partition(const std::vector<unsigned int>& num_compute_units) const;

		std::vector<device_partition>
		supported_partitions() const;

		std::vector<device_partition>
		partitions() const;
		#endif

		#if CL_TARGET_VERSION >= 110 && defined(cl_ext_device_fission)
		std::vector<ext::device>
		partition(const ext::partition_properties& prop) const;
		#endif

		#if CL_TARGET_VERSION >= 210
		nanoseconds host_time() const;
		std::pair<nanoseconds,nanoseconds> device_and_host_time() const;
		std::string intermediate_languages() const;
		#endif

		nanoseconds timer_resolution() const;
		nanoseconds timer_offset() const;

		std::string name() const;
		std::string profile() const;
		std::string vendor() const;
		std::string version() const;
		std::string driver_version() const;
		::clx::extensions extensions() const;
		#if defined(CL_DEVICE_SPIR_VERSIONS)
		std::string spir_versions() const;
		#endif

		unsigned_int_type vendor_id() const;
		::clx::platform platform() const;
		::clx::context context() const;

		inline ::clx::command_queue
		queue(command_queue_flags flags) const {
			command_queue_properties prop;
			prop.flags(flags);
			#if CL_TARGET_VERSION >= 200
			return this->queue_200(this->context().get(), prop);
			#else
			return this->queue_100(this->context().get(), prop);
			#endif
		}

		inline ::clx::command_queue
		queue(command_queue_flags flags, unsigned_int_type size) const {
			command_queue_properties prop;
			prop.flags(flags);
			prop.size(size);
			#if CL_TARGET_VERSION >= 200
			return this->queue_200(this->context().get(), prop);
			#else
			return this->queue_100(this->context().get(), prop);
			#endif
		}

		inline ::clx::command_queue
		queue(command_queue_properties properties) const {
			#if CL_TARGET_VERSION >= 200
			return this->queue_200(this->context().get(), properties);
			#else
			return this->queue_100(this->context().get(), properties);
			#endif
		}

		bool available() const;
		bool compiler_available() const;
		bool little_endian() const;
		bool supports_error_correction() const;
		bool supports_images() const;

		size_t image2d_max_width() const;
		size_t image2d_max_height() const;
		#if CL_TARGET_VERSION >= 120
		unsigned_int_type image2d_pitch_alignment() const;
		unsigned_int_type image2d_base_address_alignment() const;
		#endif

		size_t image3d_max_width() const;
		size_t image3d_max_height() const;
		size_t image3d_max_depth() const;

		unsigned_long_type global_memory_size() const;
		unsigned_long_type global_memory_cache_size() const;
		unsigned_int_type global_memory_cacheline_size() const;
		device_memory_cache global_memory_cache_type() const;
		unsigned_long_type local_memory_size() const;
		device_local_memory local_memory_type() const;

		unsigned_int_type address_bits() const;
		unsigned_int_type base_address_alignment() const;
		unsigned_int_type min_data_alignment() const;

		execution_flags execution_capabilities() const;

		template <class T>
		floating_point_flags
		floating_point_capabilities() const;

		template <class T>
		unsigned_int_type
		preferred_vector_width() const;

		unsigned_int_type max_clock_frequency() const;
		unsigned_int_type max_compute_units() const;

		unsigned_int_type max_constant_arguments() const;
		unsigned_int_type max_read_image_arguments() const;
		unsigned_int_type max_write_image_arguments() const;
		unsigned_int_type max_samplers() const;
		size_t max_parameter_size() const;

		unsigned_long_type max_constant_buffer_size() const;
		unsigned_long_type max_memory_allocation_size() const;

		size_t max_work_group_size() const;
		unsigned_int_type max_work_item_dimensions() const;
		std::vector<size_t> max_work_item_sizes() const;

		command_queue_flags queue_properties() const;
		device_flags type() const;

		unsigned_int_type compute_capability_major() const;
		unsigned_int_type compute_capability_minor() const;
		unsigned_int_type max_registers() const;
		unsigned_int_type warp_size() const;
		bool overlap() const;
		bool kernel_execution_timeout() const;
		bool integrated_memory() const;

		std::string board_name() const;
		unsigned_int_type wavefront_width() const;
		unsigned_int_type simd_per_compute_unit() const;
		unsigned_int_type simd_width() const;
		unsigned_int_type simd_instruction_width() const;
		unsigned_int_type num_global_memory_channels() const;
		unsigned_int_type num_global_memory_channel_banks() const;
		unsigned_int_type num_global_memory_channel_bank_width() const;
		unsigned_int_type local_memory_size_per_compute_unit() const;
		unsigned_int_type num_local_memory_banks() const;
		bool supports_thread_trace() const;
		unsigned_int_type gfxip_major() const;
		unsigned_int_type gfxip_minor() const;
		unsigned_int_type num_asynchronous_queues() const;
		size_t preferred_work_group_size() const;
		unsigned_long_type preferred_constant_buffer_size() const;
		unsigned_int_type pcie_id() const;
		std::vector<size_t> global_free_memory() const;

		unsigned_int_type max_named_barriers() const;

		#if defined(cl_arm_core_id) && CL_TARGET_VERSION >= 120
		unsigned_long_type compute_units_mask() const;
		#endif

		inline device_type
		get() noexcept {
			return this->_ptr;
		}

		inline const device_type
		get() const noexcept {
			return this->_ptr;
		}

		device() = default;
		inline ~device() { this->release(); }
		inline device(const device& rhs): _ptr(rhs._ptr) { this->retain(); }

		inline device&
		operator=(const device& rhs) {
			device tmp(rhs);
			this->swap(tmp);
			return *this;
		}

		inline device(device&& rhs): _ptr(rhs._ptr) { rhs._ptr = nullptr; }
		inline device& operator=(device&& rhs) { this->swap(rhs); return *this; }

		inline void
		release() {
			if (this->_ptr) {
				CLX_CHECK(::clReleaseDevice(this->_ptr));
				this->_ptr = nullptr;
			}
		}

		inline void
		retain() {
			if (this->_ptr) {
				CLX_CHECK(::clRetainDevice(this->_ptr));
			}
		}

		inline void
		swap(device& rhs) {
			std::swap(this->_ptr, rhs._ptr);
		}

	private:

		#if CL_TARGET_VERSION >= 120
		std::vector<device_partition>
		supported_partitions_priv() const;
		#endif

		#if CL_TARGET_VERSION >= 200
		::clx::command_queue
		queue_200(context_type ctx, const command_queue_properties& prop) const;
		#endif

		#if CL_TARGET_VERSION <= 120 || defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
		::clx::command_queue
		queue_100(context_type ctx, const command_queue_properties& prop) const;
		#endif

		friend class context;

	};

	static_assert(sizeof(device) == sizeof(device_type), "bad size");

	inline void
	swap(device& lhs, device& rhs) {
		lhs.swap(rhs);
	}

}

#endif // vim:filetype=cpp
