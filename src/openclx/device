#ifndef OPENCLX_DEVICE
#define OPENCLX_DEVICE

#include <chrono>
#include <string>
#include <vector>

#include <openclx/command_queue>
#include <openclx/command_queue_flags>
#include <openclx/context>
#include <openclx/device_affinity_domain>
#include <openclx/device_flags>
#include <openclx/device_local_memory>
#include <openclx/device_memory_cache>
#include <openclx/device_partition>
#include <openclx/error>
#include <openclx/execution_flags>
#include <openclx/floating_point_flags>
#include <openclx/types>

namespace clx {

	class device {

	public:
		typedef std::chrono::nanoseconds nanoseconds;

	private:
		device_type _ptr = nullptr;

	public:

		inline explicit
		device(device_type ptr): _ptr(ptr) {}

		#if CL_TARGET_VERSION >= 120
		device parent() const;

		unsigned_int_type max_subordinate_devices() const;
		device_affinity_domain affinity_domain() const;

		std::vector<device>
		partition(unsigned int num_compute_units) const;

		std::vector<device>
		partition(const std::vector<unsigned int>& num_compute_units) const;

		std::vector<device_partition>
		supported_partitions() const;

		std::vector<device_partition>
		partitions() const;
		#endif

		#if CL_TARGET_VERSION >= 210
		nanoseconds host_time() const;
		std::pair<nanoseconds,nanoseconds> device_and_host_time() const;
		#endif

		nanoseconds timer_resolution() const;

		std::string name() const;
		std::string profile() const;
		std::string vendor() const;
		std::string version() const;
		std::string driver_version() const;
		std::string extensions() const;

		unsigned_int_type vendor_id() const;
		::clx::platform platform() const;
		::clx::context context() const;

		inline ::clx::command_queue
		queue(command_queue_flags flags) const {
			#if CL_TARGET_VERSION >= 200
			return this->queue_200(this->context().get(), flags);
			#else
			return this->queue_100(this->context().get(), flags);
			#endif
		}

		bool available() const;
		bool compiler_available() const;
		bool little_endian() const;
		bool supports_error_correction() const;
		bool supports_images() const;

		size_t image2d_max_width() const;
		size_t image2d_max_height() const;
		size_t image3d_max_width() const;
		size_t image3d_max_height() const;
		size_t image3d_max_depth() const;

		unsigned_long_type global_memory_size() const;
		unsigned_long_type global_memory_cache_size() const;
		unsigned_int_type global_memory_cacheline_size() const;
		device_memory_cache global_memory_cache_type() const;
		unsigned_long_type local_memory_size() const;
		device_local_memory local_memory_type() const;

		unsigned_int_type address_bits() const;
		unsigned_int_type base_address_alignment() const;
		unsigned_int_type min_data_alignment() const;

		execution_flags execution_capabilities() const;

		template <class T>
		floating_point_flags
		floating_point_capabilities() const;

		template <class T>
		unsigned_int_type
		preferred_vector_width() const;

		unsigned_int_type max_clock_frequency() const;
		unsigned_int_type max_compute_units() const;

		unsigned_int_type max_constant_arguments() const;
		unsigned_int_type max_read_image_arguments() const;
		unsigned_int_type max_write_image_arguments() const;
		unsigned_int_type max_samplers() const;
		size_t max_parameter_size() const;

		unsigned_long_type max_constant_buffer_size() const;
		unsigned_long_type max_memory_allocation_size() const;

		size_t max_work_group_size() const;
		unsigned_int_type max_work_item_dimensions() const;
		std::vector<size_t> max_work_item_sizes() const;

		command_queue_flags queue_properties() const;
		device_flags type() const;

		inline device_type
		get() noexcept {
			return this->_ptr;
		}

		inline const device_type
		get() const noexcept {
			return this->_ptr;
		}

		device() = default;
		inline ~device() { this->release(); }
		inline device(const device& rhs): _ptr(rhs._ptr) { this->retain(); }

		inline device&
		operator=(const device& rhs) {
			device tmp(rhs);
			this->swap(tmp);
			return *this;
		}

		inline device(device&& rhs): _ptr(rhs._ptr) { rhs._ptr = nullptr; }
		inline device& operator=(device&& rhs) { this->swap(rhs); return *this; }

		inline void
		release() {
			if (this->_ptr) {
				CLX_CHECK(::clReleaseDevice(this->_ptr));
				this->_ptr = nullptr;
			}
		}

		inline void
		retain() {
			if (this->_ptr) {
				CLX_CHECK(::clRetainDevice(this->_ptr));
			}
		}

		inline void
		swap(device& rhs) {
			std::swap(this->_ptr, rhs._ptr);
		}

	private:

		#if CL_TARGET_VERSION >= 120
		std::vector<device_partition>
		supported_partitions_priv() const;
		#endif

		#if CL_TARGET_VERSION >= 200
		::clx::command_queue
		queue_200(context_type ctx, command_queue_flags flags) const;
		#endif

		#if CL_TARGET_VERSION <= 120 || defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
		::clx::command_queue
		queue_100(context_type ctx, command_queue_flags flags) const;
		#endif

		friend class context;

	};

	static_assert(sizeof(device) == sizeof(device_type), "bad size");

	inline void
	swap(device& lhs, device& rhs) {
		lhs.swap(rhs);
	}

}

#endif // vim:filetype=cpp
