#ifndef OPENCLX_EVENT_STACK
#define OPENCLX_EVENT_STACK

#include <vector>

#include <openclx/color>
#include <openclx/command_queue>
#include <openclx/event>
#include <openclx/map_flags>
#include <openclx/migration_flags>
#include <openclx/native_kernel>
#include <openclx/pattern>
#include <openclx/range>
#include <openclx/slice>

namespace clx {

	class event_stack {

	public:
		typedef std::vector<event> event_array;
		typedef std::vector<event_array> frame_array;
		typedef slice_3d<const buffer&> buffer_slice_3d;
		typedef slice_3d<const image&> image_slice_3d;
		typedef slice_3d<host_pointer> host_slice_3d;
		typedef slice_3d<const_host_pointer> const_host_slice_3d;
		typedef array_view<memory_object> memory_object_array;
		typedef void* svm_pointer;
		typedef array_view<void> svm_array;
		#if defined(cl_khr_gl_sharing)
		typedef array_view<gl::buffer> gl_memory_object_array;
		#endif
		#if defined(cl_khr_egl_image)
		typedef array_view<egl::image> egl_memory_object_array;
		#endif

	private:

		struct step_guard {

			bool& sync;
			event_array& frame;
			unsigned_int_type nevents = 0;
			const event_type* events = nullptr;

			step_guard(bool& sync, event_array& frame):
			sync(sync), frame(frame) {
				if (sync && !frame.empty()) {
					events = reinterpret_cast<const event_type*>(frame.data());
					nevents = frame.size();
				}
			}

			~step_guard() {
				if (sync) { frame.clear(); sync = false; }
			}

		};

	private:
		command_queue _queue;
		frame_array _frames;
		bool _sync = false;

	public:

		event_stack() = default;

		inline explicit
		event_stack(command_queue queue): _queue(queue) {}

		void
		wait();

		inline void
		barrier() {
			#if CL_TARGET_VERSION >= 120
			this->barrier_120();
			#else
			this->barrier_100();
			#endif
		}

		inline void
		marker() {
			#if CL_TARGET_VERSION >= 120
			this->marker_120();
			#else
			this->marker_100();
			#endif
		}

		void
		kernel(const ::clx::kernel& k);

		inline void
		kernel(const ::clx::kernel& k, const range& global) {
			this->kernel(k, {}, global, {});
		}

		inline void
		kernel(const ::clx::kernel& k, const range& global, const range& local) {
			this->kernel(k, {}, global, local);
		}

		void
		kernel(
			const ::clx::kernel& k,
			const range& offset,
			const range& global,
			const range& local
		);

		template <class ... Args>
		inline void
		kernel(native_kernel_type k, const Args& ... args_in) {
			const auto& args = make_arguments(args_in...);
			auto& frame = this->frame();
			event_type ret;
			{
				step_guard g(this->_sync, frame);
				unsigned_int_type nobjects = 0;
				std::vector<memory_object_type> objects;
				std::vector<void*> locations;
				args.memory_objects(nobjects, objects, locations);
				CLX_CHECK(::clEnqueueNativeKernel(
					this->_queue.get(), k, &args, sizeof(args),
					nobjects, objects.data(), locations.data(),
					g.nevents, g.events, &ret
				));
			}
			frame.emplace_back(std::move(ret));
		}

		void copy(const buffer_slice& src, host_pointer dst);
		void copy(const image_slice_3d& src, host_pointer dst);
		void copy(const image& src, host_pointer dst);
		void copy(const_host_pointer src, const buffer_slice& dst);
		void copy(const_host_pointer src, const image_slice_3d& dst);
		void copy(const_host_pointer src, const image& dst);
		void copy(const buffer_slice& src, const buffer_slice& dst);
		void copy(const buffer& src, const buffer& dst);
		void copy(const image_slice_3d& src, const image_slice_3d& dst);
		void copy(const image& src, const image& dst);
		void copy(const image_slice_3d& src, const buffer_slice& dst);
		void copy(const image_slice_3d& src, const buffer& dst);
		void copy(const image& src, const buffer& dst);
		void copy(const buffer_slice& src, const image_slice_3d& dst);
		void copy(const buffer_slice& src, const image& dst);
		void copy(const buffer& src, const image& dst);
		#if CL_TARGET_VERSION >= 110
		void copy(const buffer_slice_3d& src, const buffer_slice_3d& dst);
		void copy(const const_host_slice_3d& src, const buffer_slice_3d& dst);
		void copy(const buffer_slice_3d& src, const host_slice_3d& dst);
		#endif

		inline void
		migrate(migration_flags flags, const memory_object_array& objects) {
			#if CL_TARGET_VERSION >= 120
			this->migrate_120(flags, objects);
			#else
			this->migrate_ext(flags, objects);
			#endif
		}

		#if defined(cl_khr_gl_sharing)
		void acquire(const gl_memory_object_array& objects);
		void release(const gl_memory_object_array& objects);
		#endif

		#if defined(cl_khr_egl_image)
		void acquire(const egl_memory_object_array& objects);
		void release(const egl_memory_object_array& objects);
		#endif

		#if CL_TARGET_VERSION >= 120
		void fill(const buffer_slice& dst, const pattern& pattern);
		void fill(const buffer& dst, const pattern& pattern);
		void fill(const image_slice_3d& dst, const color& col);
		void fill(const image& dst, const color& col);
		template <class ... Args> inline void
		migrate(migration_flags flags, const Args& ... objects) {
			memory_object arr[] {objects...};
			this->migrate(flags, {arr, sizeof...(objects)});
		}
		#if defined(cl_img_use_gralloc_ptr)
		void acquire_gralloc(const memory_object_array& objects);
		void release_gralloc(const memory_object_array& objects);
		#endif
		#endif

		#if CL_TARGET_VERSION >= 200
		void free(const array_view<svm_pointer>& pointers);
		void fill(svm_array ptr, const pattern& pattern);
		void copy(const svm_array& src, const svm_array& dst);
		void map(const svm_array& src, map_flags flags);
		void unmap(svm_pointer ptr);
		#endif

		#if CL_TARGET_VERSION >= 210
		void migrate(
			migration_flags flags,
			const array_view<array_view<svm_pointer>>& pointers
		);
		#endif

		host_pointer
		map(const buffer_slice& b, map_flags flags);

		host_pointer
		map(const buffer& b, map_flags flags);

		host_pointer
		map(
			const image_slice_3d& src, map_flags flags,
			size_t& row_pitch, size_t& slice_pitch
		);

		host_pointer
		map(
			const image& src, map_flags flags,
			size_t& row_pitch, size_t& slice_pitch
		);

		void
		unmap(const memory_object& obj, host_pointer ptr);

		inline void
		step() {
			this->_sync = true;
		}

		inline void
		insert(event&& ev) {
			this->frame().emplace_back(std::forward<event>(ev));
		}

		inline const command_queue&
		queue() const {
			return this->_queue;
		}

		inline command_queue
		queue() {
			return this->_queue;
		}

	private:

		inline void
		step_in() {
			this->_frames.emplace_back();
		}

		inline void
		step_out() {
			this->_frames.pop_back();
		}

		inline const event_array&
		frame() const {
			return this->_frames.back();
		}

		inline event_array&
		frame() {
			return this->_frames.back();
		}

		#if CL_TARGET_VERSION >= 120
		void
		barrier_120();
		#endif

		#if CL_TARGET_VERSION <= 110 || defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
		void
		barrier_100();
		#endif

		#if CL_TARGET_VERSION >= 120
		void
		marker_120();
		#endif

		#if CL_TARGET_VERSION <= 110 || defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
		void
		marker_100();
		#endif

		#if CL_TARGET_VERSION >= 120
		void
		migrate_120(migration_flags flags, const memory_object_array& objects);
		#endif

		#if defined(cl_ext_migrate_memobject)
		void
		migrate_ext(migration_flags flags, const memory_object_array& objects);
		#endif

		#if CL_TARGET_VERSION >= 120
		friend class pattern;
		#endif

	};

}

#endif // vim:filetype=cpp
