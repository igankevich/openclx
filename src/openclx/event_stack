#ifndef OPENCLX_EVENT_STACK
#define OPENCLX_EVENT_STACK

#include <vector>

#include <openclx/command_queue>
#include <openclx/event>
#include <openclx/map_flags>
#include <openclx/native_kernel>
#include <openclx/range>
#include <openclx/slice>

namespace clx {

	class event_stack {

	public:
		struct frame_type {
			size_t offset = 0;
			size_t size = 0;
			frame_type() = default;
			frame_type(size_t offset, size_t size):
			offset(offset), size(size) {}
		};

	public:
		typedef std::vector<event> event_array;
		typedef std::vector<event_array> frame_array;
		typedef slice_3d<const buffer&> buffer_slice_3d;
		typedef slice_3d<const image&> image_slice_3d;
		typedef slice_3d<host_pointer> host_slice_3d;
		typedef slice_3d<const_host_pointer> const_host_slice_3d;

	private:

		struct step_guard {

			bool _sync;
			event_array& frame;
			unsigned_int_type nevents = 0;
			const event_type* events = nullptr;

			step_guard(bool sync, event_array& frame):
			_sync(sync), frame(frame) {
				if (this->_sync && !frame.empty()) {
					events = reinterpret_cast<const event_type*>(frame.data());
					nevents = frame.size();
				}
			}

			~step_guard() {
				if (this->_sync) {
					frame.clear();
					this->_sync = false;
				}
			}

		};

	private:
		command_queue _queue;
		frame_array _frames;
		bool _sync = false;

	public:

		event_stack() = default;

		inline explicit
		event_stack(command_queue queue): _queue(queue) {}

		void
		wait();

		inline void
		barrier() {
			#if CL_TARGET_VERSION >= 120
			this->barrier_120();
			#else
			this->barrier_100();
			#endif
		}

		inline void
		marker() {
			#if CL_TARGET_VERSION >= 120
			this->marker_120();
			#else
			this->marker_100();
			#endif
		}

		void
		kernel(const ::clx::kernel& k);

		inline void
		kernel(const ::clx::kernel& k, const range& global) {
			this->kernel(k, {}, global, {});
		}

		inline void
		kernel(const ::clx::kernel& k, const range& global, const range& local) {
			this->kernel(k, {}, global, local);
		}

		void
		kernel(
			const ::clx::kernel& k,
			const range& offset,
			const range& global,
			const range& local
		);

		template <class ... Args>
		inline void
		kernel(native_kernel_type k, const Args& ... args_in) {
			const auto& args = make_arguments(args_in...);
			auto& frame = this->frame();
			event_type ret;
			{
				step_guard g(this->_sync, frame);
				unsigned_int_type nobjects = 0;
				std::vector<memory_object_type> objects;
				std::vector<void*> locations;
				args.memory_objects(nobjects, objects, locations);
				CLX_CHECK(::clEnqueueNativeKernel(
					this->_queue.get(), k, &args, sizeof(args),
					nobjects, objects.data(), locations.data(),
					g.nevents, g.events, &ret
				));
			}
			frame.emplace_back(std::move(ret));
		}

		void copy(const buffer_slice& src, host_pointer dst);
		void copy(const image_slice_3d& src, host_pointer dst);
		void copy(const image& src, host_pointer dst);
		void copy(const_host_pointer src, const buffer_slice& dst);
		void copy(const_host_pointer src, const image_slice_3d& dst);
		void copy(const_host_pointer src, const image& dst);
		void copy(const buffer_slice& src, const buffer_slice& dst);
		void copy(const buffer& src, const buffer& dst);
		void copy(const image_slice_3d& src, const image_slice_3d& dst);
		void copy(const image& src, const image& dst);
		void copy(const image_slice_3d& src, const buffer_slice& dst);
		void copy(const image_slice_3d& src, const buffer& dst);
		void copy(const image& src, const buffer& dst);
		void copy(const buffer_slice& src, const image_slice_3d& dst);
		void copy(const buffer_slice& src, const image& dst);
		void copy(const buffer& src, const image& dst);
		#if CL_TARGET_VERSION >= 110
		void copy(const buffer_slice_3d& src, const buffer_slice_3d& dst);
		void copy(const const_host_slice_3d& src, const buffer_slice_3d& dst);
		void copy(const buffer_slice_3d& src, const host_slice_3d& dst);
		#endif

		host_pointer
		map(const buffer_slice& b, map_flags flags);

		host_pointer
		map(const buffer& b, map_flags flags);

		host_pointer
		map(
			const image_slice_3d& src, map_flags flags,
			size_t& row_pitch, size_t& slice_pitch
		);

		host_pointer
		map(
			const image& src, map_flags flags,
			size_t& row_pitch, size_t& slice_pitch
		);

		void
		unmap(const memory_object& obj, host_pointer ptr);

		inline void
		step() {
			this->_sync = true;
		}

		inline void
		insert(event&& ev) {
			this->frame().emplace_back(std::forward<event>(ev));
		}

		inline const command_queue&
		queue() const {
			return this->_queue;
		}

		inline command_queue
		queue() {
			return this->_queue;
		}

	private:

		inline void
		step_in() {
			this->_frames.emplace_back();
		}

		inline void
		step_out() {
			this->_frames.pop_back();
		}

		inline const event_array&
		frame() const {
			return this->_frames.back();
		}

		inline event_array&
		frame() {
			return this->_frames.back();
		}

		#if CL_TARGET_VERSION >= 120
		void
		barrier_120();
		#endif

		#if CL_TARGET_VERSION <= 110 || defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
		void
		barrier_100();
		#endif

		#if CL_TARGET_VERSION >= 120
		void
		marker_120();
		#endif

		#if CL_TARGET_VERSION <= 110 || defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
		void
		marker_100();
		#endif

	};

}

#endif // vim:filetype=cpp
