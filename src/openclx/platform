#ifndef OPENCLX_PLATFORM
#define OPENCLX_PLATFORM

#include <chrono>
#include <string>
#include <vector>

#include <openclx/device_flags>
#include <openclx/error>
#include <openclx/forward>

namespace clx {

	enum class extension_function {
		clCreateCommandQueueWithPropertiesKHR,
		clTerminateContextKHR,
		clEnqueueMigrateMemObjectEXT,
		clGetKernelSubGroupInfoKHR,
		clGetGLContextInfoKHR,
		clCreateEventFromEGLSyncKHR,
		clCreateFromEGLImageKHR,
		clEnqueueAcquireEGLObjectsKHR,
		clEnqueueReleaseEGLObjectsKHR,
		clImportMemoryARM,
		clReleaseDeviceEXT,
		clRetainDeviceEXT,
		clCreateSubDevicesEXT,
		clSVMAllocARM,
		clSVMFreeARM,
		clEnqueueSVMFreeARM,
		clEnqueueSVMMemcpyARM,
		clEnqueueSVMMemFillARM,
		clEnqueueSVMMapARM,
		clEnqueueSVMUnmapARM,
		clSetKernelArgSVMPointerARM,
		clSetKernelExecInfoARM,
		clCreateAcceleratorINTEL,
		clGetAcceleratorInfoINTEL,
		clRetainAcceleratorINTEL,
		clReleaseAcceleratorINTEL,
		size
	};

	class platform {

	public:
		typedef std::chrono::nanoseconds nanoseconds;
		typedef void* function_address;

	private:
		platform_type _ptr = nullptr;
		mutable std::vector<function_address> _functions;

	public:

		inline explicit
		platform(platform_type ptr): _ptr(ptr) {}

		std::string profile() const;
		std::string version() const;
		std::string name() const;
		std::string vendor() const;
		::clx::extensions extensions() const;
		#if defined(CL_PLATFORM_ICD_SUFFIX_KHR)
		std::string suffix() const;
		#endif

		std::vector<device>
		devices(device_flags types) const;

		::clx::context context(const array_view<device>& devices) const;
		::clx::context context(const context_properties&,const array_view<device>&) const;
		::clx::context context(device_flags types=device_flags::all) const;
		::clx::context context(const context_properties&,device_flags=device_flags::all) const;

		inline void
		unload_compiler() {
			#if CL_TARGET_VERSION >= 120
			CLX_CHECK(::clUnloadPlatformCompiler(this->_ptr));
			#else
			CLX_CHECK(::clUnloadCompiler());
			#endif
		}

		inline void*
		extension_function_address(const char* name) const {
			#if CL_TARGET_VERSION >= 120
			return ::clGetExtensionFunctionAddressForPlatform(this->_ptr, name);
			#else
			return ::clGetExtensionFunctionAddress(name);
			#endif
		}

		template <class Function>
		inline Function
		extension(const char* name) const {
			return reinterpret_cast<Function>(extension_function_address(name));
		}

		template <class Function>
		inline Function
		function(extension_function func) const {
			return reinterpret_cast<Function>(this->do_function(func));
		}

		#if CL_TARGET_VERSION >= 210
		nanoseconds timer_resolution() const;
		#endif

		platform() = default;
		~platform() = default;
		platform(const platform&) = default;
		platform& operator=(const platform&) = default;

		inline
		platform(platform&& rhs): _ptr(rhs._ptr) { rhs._ptr = nullptr; }

		inline platform&
		operator=(platform&& rhs) {
			this->_ptr = rhs._ptr;
			rhs._ptr = nullptr;
			this->_functions = std::move(rhs._functions);
			return *this;
		}

		inline void
		swap(platform& rhs) {
			std::swap(this->_ptr, rhs._ptr);
			std::swap(this->_functions, rhs._functions);
		}

		inline platform_type
		get() noexcept {
			return this->_ptr;
		}

		inline const platform_type
		get() const noexcept {
			return this->_ptr;
		}

	private:

		function_address
		do_function(extension_function func) const;

	};

	inline void
	swap(platform& lhs, platform& rhs) {
		lhs.swap(rhs);
	}

	std::vector<platform>
	platforms();

	#if CL_TARGET_VERSION <= 110 || defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
	inline void
	unload_compiler() {
		CLX_CHECK(::clUnloadCompiler());
	}
	#endif

	#if CL_TARGET_VERSION <= 110 || defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
	inline void*
	extension_function_address(const char* name) {
		return ::clGetExtensionFunctionAddress(name);
	}
	#endif

}

#endif // vim:filetype=cpp
